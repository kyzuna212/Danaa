/*
 * Generated by the Jasper component of Apache Tomcat
 * Version: Apache Tomcat/8.5.57
 * Generated at: 2020-09-08 02:59:24 UTC
 * Note: The last modified time of this file was set to
 *       the last modified time of the source file after
 *       generation to assist with modification tracking.
 */
package org.apache.jsp.WEB_002dINF.views.test;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;

public final class testAOPPage_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent,
                 org.apache.jasper.runtime.JspSourceImports {

  private static final javax.servlet.jsp.JspFactory _jspxFactory =
          javax.servlet.jsp.JspFactory.getDefaultFactory();

  private static java.util.Map<java.lang.String,java.lang.Long> _jspx_dependants;

  private static final java.util.Set<java.lang.String> _jspx_imports_packages;

  private static final java.util.Set<java.lang.String> _jspx_imports_classes;

  static {
    _jspx_imports_packages = new java.util.HashSet<>();
    _jspx_imports_packages.add("javax.servlet");
    _jspx_imports_packages.add("javax.servlet.http");
    _jspx_imports_packages.add("javax.servlet.jsp");
    _jspx_imports_classes = null;
  }

  private volatile javax.el.ExpressionFactory _el_expressionfactory;
  private volatile org.apache.tomcat.InstanceManager _jsp_instancemanager;

  public java.util.Map<java.lang.String,java.lang.Long> getDependants() {
    return _jspx_dependants;
  }

  public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
  }

  public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
  }

  public javax.el.ExpressionFactory _jsp_getExpressionFactory() {
    if (_el_expressionfactory == null) {
      synchronized (this) {
        if (_el_expressionfactory == null) {
          _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
        }
      }
    }
    return _el_expressionfactory;
  }

  public org.apache.tomcat.InstanceManager _jsp_getInstanceManager() {
    if (_jsp_instancemanager == null) {
      synchronized (this) {
        if (_jsp_instancemanager == null) {
          _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
        }
      }
    }
    return _jsp_instancemanager;
  }

  public void _jspInit() {
  }

  public void _jspDestroy() {
  }

  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
      throws java.io.IOException, javax.servlet.ServletException {

    final java.lang.String _jspx_method = request.getMethod();
    if (!"GET".equals(_jspx_method) && !"POST".equals(_jspx_method) && !"HEAD".equals(_jspx_method) && !javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) {
      response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "JSP들은 오직 GET, POST 또는 HEAD 메소드만을 허용합니다. Jasper는 OPTIONS 메소드 또한 허용합니다.");
      return;
    }

    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;


    try {
      response.setContentType("text/html; charset=UTF-8");
      pageContext = _jspxFactory.getPageContext(this, request, response,
      			null, true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;

      out.write("\r\n");
      out.write("<!DOCTYPE html>\r\n");
      out.write("<html>\r\n");
      out.write("<head>\r\n");
      out.write("<meta charset=\"UTF-8\">\r\n");
      out.write("<title>second</title>\r\n");
      out.write("</head>\r\n");
      out.write("<body>\r\n");
      out.write("<h1>spring AOP test page</h1>\r\n");
      out.write("<!-- 스프링에서의 절대경로 사용법 -->   <!-- /second webapp까지의 경로 -->\r\n");
      out.write("<img alt=\"절대경로연습용 이미지\" src=\"");
      out.write((java.lang.String) org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate("${pageContext.request.contextPath}", java.lang.String.class, (javax.servlet.jsp.PageContext)_jspx_page_context, null));
      out.write("/resources/images/고엉이.png\" width=\"100\" height=\"50\">\r\n");
      out.write("<br>\r\n");
      out.write("<hr>\r\n");
      out.write("<h2>AOP (Aspect Oriented Programming : 관점 지향 프로그래밍)</h2>\r\n");
      out.write("<h4>Aspect에 대한 Advice를 Target Object 의 Join point에 해당하는 \r\n");
      out.write("pointcut에 weaving되게 설정하는 것 : 비즈니스 로직을 처리하는 클래스\r\n");
      out.write("(Service, Repository : Dao)에 주로 사용함</h4>\r\n");
      out.write("<!-- 지정하는 pointcut에 들어가서 작동하는 weaving -->\r\n");
      out.write("<h4>OOP 에서는 클래스별로 중복되는 공통기능을 하나의 클래스로 분리하여 작성하고,\r\n");
      out.write(" 사용이 필요한 다른 클래스의 메소드 안 실행 위치에 작성 사용함</h4>\r\n");
      out.write(" <h4>스프링에서의 AOP 는 분리한 공통 기능을 직접적으로 호출하지 않는다.\r\n");
      out.write(" 분리한 공통 기능의 호출을 관점(Aspect)으로 다룬다.</h4>\r\n");
      out.write(" 즉, 각 모듈에 호출 코드를 횡단 관점이라고 하고, AOP에서는 횡단 관점까지 분리하는 것이 목표이다.<br>\r\n");
      out.write(" 각 모듈에 분리된 공통 기능에 대한 호출 코드를 완전히 제거하는 것이 스프링의 AOP임.<br>\r\n");
      out.write(" <hr>\r\n");
      out.write(" <ol>\r\n");
      out.write(" <li><h5>Join Point</h5>\r\n");
      out.write(" \t<ul>\r\n");
      out.write(" \t\t<li>메소드가 실행되는 지점을 의미함</li>\r\n");
      out.write(" \t\t<li>클래스의 객체(인스턴스) 생성 시점, 메소드 호출 시점,\r\n");
      out.write(" \t\t 예외 발생 시점 등의 특정 작업(기능 : 메소드)이 시작되는 시점을 말함</li>\r\n");
      out.write(" \t\t <li>Advice를 적용할 수 있는 시점임</li>\r\n");
      out.write(" \t</ul>\r\n");
      out.write("</li>\r\n");
      out.write("<li><h5>Advice (어드바이스)</h5>\r\n");
      out.write("\t<ul>\r\n");
      out.write("\t\t<li>Join Point에서 구동될 메소드를 의미함</li>\r\n");
      out.write("\t\t<li>Join Point에 삽입되어져 동작될 코드(기능/행위)를 말함</li> \r\n");
      out.write("\t\t<!-- throwing Advice :메소드 실행시 예외 발생시  \r\n");
      out.write("\t\t\tAfter (finally) Advice :끝에 반드시 구동(예외여부 상관 x)\r\n");
      out.write("\t\t\tAround Advice : 전과 후 둘다 구동-->\r\n");
      out.write("\t\t<li>Before Advice, After returning Advice, After throwing Advice,\r\n");
      out.write("\t\t\tAfter (finally) Advice, Around Advice가 있음</li>\r\n");
      out.write("\t</ul>\r\n");
      out.write("\r\n");
      out.write("</li> \r\n");
      out.write("<li><h5>Pointcut</h5>\r\n");
      out.write("\t<ul>\r\n");
      out.write("\t\t<li>Join point 의 부분집합 : 어드바이스가 조인포인트에 위빙되도록 설정해 놓은 것</li>\r\n");
      out.write("\t\t<li>실제 어드바이스가 적용되는 조인 포인트를 말함 : 클래스 또는 메소드로 작성됨</li>\r\n");
      out.write("\t\t<li>정규 표현식이나 AspectJ 문법을 이용하여 포인트컷을 정의할 수 있음</li>\r\n");
      out.write("\t</ul>\r\n");
      out.write("</li>\r\n");
      out.write("<li><h5>Weaving</h5>\r\n");
      out.write("\t<ul>\r\n");
      out.write("\t\t<li>어드바이스(공통 코드)를 핵심 로직코드(타겟 메소드)에 삽입하는 것</li>\r\n");
      out.write("\t\t<li>어드바이스를 위빙하는 방식 3가지</li>\r\n");
      out.write("\t\t<ol>\r\n");
      out.write("\t\t\t<li>컴파일시에 위빙하기 : AOP가 적용된 클래스 파일을 새로 생성함</li>\r\n");
      out.write("\t\t\t<li>클래스 로딩시에 위빙하기 : 로딩한 바이트 코드를 AOP가 변경하여 사용한다.</li>\r\n");
      out.write("\t\t\t<li>런타임시에 위빙하기 : 프록시를 이용한다. (메소드 호출시 조인포인트 지원)</li>\r\n");
      out.write("\t\t</ol>\r\n");
      out.write("\t</ul>\r\n");
      out.write("</li>\r\n");
      out.write("<li><h5>Target Object</h5>\r\n");
      out.write("\t<ul>\r\n");
      out.write("\t\t<li>핵심 로직을 가진 클래스를 말함 : 서비스 클래스나 dao 클래스</li>\r\n");
      out.write("\t\t<li>어드바이스 위빙 대상 객체</li>\r\n");
      out.write("\t\t<li>스프링에서는 런타임 프록시를 사용해서 위빙 처리함</li>\r\n");
      out.write("\t</ul>\r\n");
      out.write("</li>\r\n");
      out.write("<li><h5>Aspect</h5>\r\n");
      out.write("\t<ul>\r\n");
      out.write("\t\t<li>공통 기능을 분리 작성해 놓은 클래스</li>\r\n");
      out.write("\t\t<li>분리 작성된 공통 기능(메소드)</li>\r\n");
      out.write("\t\t<li>여러 객체에 공통으로 사용되는 공통 관점 사항</li>\r\n");
      out.write("\t\t<li>로깅, 트랜잭션, 보안코드 등이 Aspect의 좋은 사용 예임</li>\r\n");
      out.write("\t</ul>\r\n");
      out.write("\r\n");
      out.write("</li>\r\n");
      out.write("\r\n");
      out.write("</ol>\r\n");
      out.write("</body>\r\n");
      out.write("</html>");
    } catch (java.lang.Throwable t) {
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null && out.getBufferSize() != 0)
          try {
            if (response.isCommitted()) {
              out.flush();
            } else {
              out.clearBuffer();
            }
          } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
}
